<html>
    <head>
        <script id="fragmentProgram" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTexCoord;

            uniform sampler2D uTexture;

            void main(void)
            {
                gl_FragColor = texture2D(uTexture, vec2(vTexCoord.s, vTexCoord.t));
            }
        </script>
        <script id="vertexProgram" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec2 aTexCoord;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;

            varying vec2 vTexCoord;

            void main(void)
            {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
                vTexCoord = aTexCoord;
            }
        </script>
        <script type="text/javascript" src="linalg.js"></script>
        <script type="text/javascript" src="resources.js"></script>
        <script type="text/javascript" src="shaders.js"></script>
        <script type="text/javascript" src="scenegraph.js"></script>
        <script type="text/javascript" charset="utf-8">
            var gl
            var g_shaderprogram
            var g_timer

            var gamesettings =
                { dt: 33
                }

            var imagelist = 
                [   { "identifier": "pan"
                    , "url":        "pan.png"
                    }
                ,   { "identifier": "fox"
                    , "url":        "cubetexture.png"
                    } 
                ]

            var renderstate
            var gs
            var resources = new Resources()
            var gfxstore

            function RenderState(matrixUniforms, aVertexPosition, aTexCoord, uTexture)
            {
                this.PROJECTION_STACK = 0
                this.MODELVIEW_STACK = 1

                this.matrixUniforms = matrixUniforms
                this.transformstack = []

                for (var i = 0; i < matrixUniforms.length; i++)
                {
                    this.transformstack.push([identityMatrix4.slice(0)])
                }

                this.render = function(mesh)
                {
                }
            }

            function quadMesh()
            {
                return 
                    [   { "vertices":
                            [ -1,  1,  0, 0, 1
                            , -1, -1,  0, 0, 0
                            ,  1,  1,  0, 1, 1
                            ,  1, -1,  0, 1, 0
                            ]
                        , "primitive": gl.TRIANGLESTRIP
                        }
                    ]
            }

            function pixelTransform()
            {
                var viewportdim = gl.getParameter(gl.VIEWPORT)
                var width = viewportdim[2]
                var height = viewportdim[3]

                var translateM = translationMatrix4(-width/2, -height/2, 0)
                var scaleM = identityMatrix4.slice(0)
                scaleM[at4(0, 0)] = 2 / width
                scaleM[at4(1, 1)] = -2 / height

                var m = mat4mul(scaleM, translateM)
                return m
            }


            function GameState()
            {
                var aVertexPosition = gl.getAttribLocation(g_shaderprogram, "aVertexPosition")
                var aTexCoord = gl.getAttribLocation(g_shaderprogram, "aTexCoord")

                // Picking
                this.hitboxes = []
                this.pickedtransform = identityMatrix4

                // SceneGraph setup
                this.sgroot = new SGNode()
                this.gameroot = new DollyNode(renderstate.PROJECTION_STACK)
                this.uiroot = new MatrixNode(renderstate.PROJECTION_STACK, pixelTransform())

                this.sgroot.attach(this.gameroot)
                this.sgroot.attach(this.uiroot)

                this.gameroot
                    .attach(new BBoxNode(this.hitboxes))
                    .attach(new ApplyTransform([0, 1]))
                    .attach(new RenderNode(aVertexPosition, aTexCoord, "pan"))
                this.uiroot
                    .attach(new MatrixNode(renderstate.MODELVIEW_STACK, translationMatrix4(25,455,0)))
                    .attach(new MatrixNode(renderstate.MODELVIEW_STACK, scaleMatrix4(50)))
                    .attach(new ApplyTransform([0, 1]))
                    .attach(new RenderNode(aVertexPosition, aTexCoord, "pan"))

                // View interaction
                this.panning = false
                this.scanning = false
                this.lastmouse = {"x": 0.0, "y": 0.0}
            }

            function initGL(canvas)
            {
                gl = canvas.getContext("experimental-webgl")
                if (!gl)
                {
                    throw "Unable to initialize WebGL"
                }

                gl.viewport(0, 0, canvas.width, canvas.height)
                gl.clearColor(0.0, 0.0, 0.0, 1.0)
                gl.enable(gl.DEPTH_TEST)

                gl.enable(gl.BLEND)
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
            }

            function checkGLError()
            {
                var errorvalue = gl.getError()
                if (errorvalue != gl.NO_ERROR)
                {
                    throw ("GL error: " + errorvalue)
                }
            }

            function initShaders()
            {
                var vertexShader = loadShader("vertexProgram")
                var fragmentShader = loadShader("fragmentProgram")
                g_shaderprogram = linkShaderProgram([vertexShader, fragmentShader])

                gl.useProgram(g_shaderprogram)
            }

            function initResources()
            {
                resources.loadfinished = initGame
                resources.load(imagelist, [])
            }

            function initGame()
            {
                var uModelViewMatrix = gl.getUniformLocation(g_shaderprogram, "uModelViewMatrix")
                var uProjectionMatrix = gl.getUniformLocation(g_shaderprogram, "uProjectionMatrix")
                var uTexture = gl.getUniformLocation(g_shaderprogram, "uTexture")

                gfxstore = new GfxStore(gl, resources, 2, 2)

                gl.bindTexture(gl.TEXTURE_2D, gfxstore.textures.getResource("pan"))
                gl.uniform1i(uTexture, 0)

                renderstate = new RenderState([uProjectionMatrix, uModelViewMatrix])
                gs = new GameState()

                timerProxy()
            }

            function timerProxy()
            {
                update()
                draw()
                g_timer = setTimeout(timerProxy, gamesettings.dt)
            }

            function update()
            {
            }

            function pick(x, y)
            {
                var picks = []

                var x0_screen = [x, y, 0]
                var x0_gl = mat4hvec3mul(pixelTransform(), x0_screen)

                gs.hitboxes.splice(0) // Clear calculated hitbox transforms
                gs.sgroot.updateWith(SGNode.CALLBACK, renderstate)

                for (var i = 0; i < gs.hitboxes.length; i++)
                {
                    var bbox_transform = gs.hitboxes[i]
                    var bbox_inv = mat4inv(bbox_transform)

                    var x0 = mat4hvec3mul(bbox_inv, x0_gl)
                    var v = mat4vec3mul(bbox_inv, [0, 0, 1])
                    var hit = closestPointOnLine(x0, v)
                    if (vec3magnitude(hit) < 1)
                    {
                        picks.push({"transform": bbox_transform})
                    }
                }
                return picks
            }

            function draw()
            {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
                gs.sgroot.updateWith(SGNode.DRAW, renderstate)
            }

            function init()
            {
                try
                {
                    var canvas = document.getElementById("glcanvas")
                    initGL(canvas)
                    initShaders()
                    initResources() // calls initGame()
                    checkGLError()
                }
                catch(e)
                {
                    setMessage("Could not initialize: " + e)
                }
            }

            function onKeyDown(e)
            {
            }

            function onKeyUp(e)
            {
            }

            function onMouseDown(e)
            {
                gs.lastmouse = localMousePosition(e, gl.canvas)
                var hits = pick(gs.lastmouse.x, gs.lastmouse.y)
                if (hits.length > 0)
                {
                    if (e.button == 2)
                    {
                        if (!e.shiftKey)
                        {
                            gs.scanning = true
                        }
                        else
                        {
                            gs.panning = true
                        }
                    }
                    gs.pickedtransform = hits[0]
                }
            }

            function onMouseUp(e)
            {
                gs.scanning = false
                gs.panning = false
            }

            function onMouseMove(e)
            {
                if (gs.scanning || gs.panning)
                {
                    var currentmouse = localMousePosition(e, gl.canvas)
                    var v0_screen =
                        [ currentmouse.x - gs.lastmouse.x
                        , currentmouse.y - gs.lastmouse.y
                        , 0]
                    gs.lastmouse = currentmouse

                    if (gs.scanning)
                    {
                        var view_inv = mat4mul(mat4inv(gs.pickedtransform.transform), pixelTransform())
                        var v0_inv = mat4vec3mul(view_inv, v0_screen)
                        gs.gameroot.scan(v0_inv[0], v0_inv[1], 0)
                    }
                    else if (gs.panning)
                    {
                        var v0_gl = mat4vec3mul(pixelTransform(), v0_screen)
                        var v0_rads = vec3scale(v0_gl, Math.PI)
                        gs.gameroot.pan(v0_rads[0], -v0_rads[1])
                    }
                }
            }

            function setMessage(msg)
            {
                var msgdiv = document.getElementById("msg")
                msgdiv.innerHTML = msg
            }

            /*
             * Find position of a HTML element
             */
            function findPosition(elem)
            {
                var x = 0
                var y = 0
                if (elem.offsetParent)
                {
                    do
                    {
                        x += elem.offsetLeft
                        y += elem.offsetTop
                    } while(elem = elem.offsetParent)
                }
                return {"x": x, "y": y}
            }

            /*
             * Find coordinates of mouse relative to HTML element
             */
            function localMousePosition(e, elem)
            {
                var p = findPosition(elem)
                return {"x": e.x - p.x, "y": e.y - p.y}
            }
        </script>
    </head>
    <body onload="init()">
        <canvas id="glcanvas" width="640" height="480" 
                onkeydown="onKeyDown(event)" 
                onkeyup="onKeyUp(event)"
                onmousedown="onMouseDown(event)"
                onmouseup="onMouseUp(event)"
                onmousemove="onMouseMove(event)"
                oncontextmenu="return false">
            Looks like there's no support for HTML5 Canvas =(
        </canvas>
        <div id="msg">
        </div>
    </body>
</html>
